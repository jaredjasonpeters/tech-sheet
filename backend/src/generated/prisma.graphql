type AggregateNTEPRow {
  count: Int!
}

type AggregateNTEPTable {
  count: Int!
}

type AggregateTechsheet {
  count: Int!
}

type AggregateToleranceRow {
  count: Int!
}

type AggregateToleranceTable {
  count: Int!
}

type AggregateUser {
  count: Int!
}

enum Amount {
  LOW
  MED
  HIGH
}

type BatchPayload {
  count: Long!
}

enum Company {
  DLF_PICKSEED
  SEED_RESEARCH_OF_OREGON
}

scalar DateTime

enum Division {
  FORAGE
  PRO_TURF
  RETAIL
}

scalar Long

type Mutation {
  createNTEPRow(data: NTEPRowCreateInput!): NTEPRow!
  updateNTEPRow(data: NTEPRowUpdateInput!, where: NTEPRowWhereUniqueInput!): NTEPRow
  updateManyNTEPRows(data: NTEPRowUpdateManyMutationInput!, where: NTEPRowWhereInput): BatchPayload!
  upsertNTEPRow(where: NTEPRowWhereUniqueInput!, create: NTEPRowCreateInput!, update: NTEPRowUpdateInput!): NTEPRow!
  deleteNTEPRow(where: NTEPRowWhereUniqueInput!): NTEPRow
  deleteManyNTEPRows(where: NTEPRowWhereInput): BatchPayload!
  createNTEPTable(data: NTEPTableCreateInput!): NTEPTable!
  updateNTEPTable(data: NTEPTableUpdateInput!, where: NTEPTableWhereUniqueInput!): NTEPTable
  updateManyNTEPTables(data: NTEPTableUpdateManyMutationInput!, where: NTEPTableWhereInput): BatchPayload!
  upsertNTEPTable(where: NTEPTableWhereUniqueInput!, create: NTEPTableCreateInput!, update: NTEPTableUpdateInput!): NTEPTable!
  deleteNTEPTable(where: NTEPTableWhereUniqueInput!): NTEPTable
  deleteManyNTEPTables(where: NTEPTableWhereInput): BatchPayload!
  createTechsheet(data: TechsheetCreateInput!): Techsheet!
  updateTechsheet(data: TechsheetUpdateInput!, where: TechsheetWhereUniqueInput!): Techsheet
  updateManyTechsheets(data: TechsheetUpdateManyMutationInput!, where: TechsheetWhereInput): BatchPayload!
  upsertTechsheet(where: TechsheetWhereUniqueInput!, create: TechsheetCreateInput!, update: TechsheetUpdateInput!): Techsheet!
  deleteTechsheet(where: TechsheetWhereUniqueInput!): Techsheet
  deleteManyTechsheets(where: TechsheetWhereInput): BatchPayload!
  createToleranceRow(data: ToleranceRowCreateInput!): ToleranceRow!
  updateToleranceRow(data: ToleranceRowUpdateInput!, where: ToleranceRowWhereUniqueInput!): ToleranceRow
  updateManyToleranceRows(data: ToleranceRowUpdateManyMutationInput!, where: ToleranceRowWhereInput): BatchPayload!
  upsertToleranceRow(where: ToleranceRowWhereUniqueInput!, create: ToleranceRowCreateInput!, update: ToleranceRowUpdateInput!): ToleranceRow!
  deleteToleranceRow(where: ToleranceRowWhereUniqueInput!): ToleranceRow
  deleteManyToleranceRows(where: ToleranceRowWhereInput): BatchPayload!
  createToleranceTable(data: ToleranceTableCreateInput!): ToleranceTable!
  updateToleranceTable(data: ToleranceTableUpdateInput!, where: ToleranceTableWhereUniqueInput!): ToleranceTable
  upsertToleranceTable(where: ToleranceTableWhereUniqueInput!, create: ToleranceTableCreateInput!, update: ToleranceTableUpdateInput!): ToleranceTable!
  deleteToleranceTable(where: ToleranceTableWhereUniqueInput!): ToleranceTable
  deleteManyToleranceTables(where: ToleranceTableWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type NTEPRow {
  id: ID!
  varietyName: String!
  rating: Float!
  table: NTEPTable
}

type NTEPRowConnection {
  pageInfo: PageInfo!
  edges: [NTEPRowEdge]!
  aggregate: AggregateNTEPRow!
}

input NTEPRowCreateInput {
  varietyName: String!
  rating: Float!
  table: NTEPTableCreateOneWithoutRowsInput
}

input NTEPRowCreateManyWithoutTableInput {
  create: [NTEPRowCreateWithoutTableInput!]
  connect: [NTEPRowWhereUniqueInput!]
}

input NTEPRowCreateWithoutTableInput {
  varietyName: String!
  rating: Float!
}

type NTEPRowEdge {
  node: NTEPRow!
  cursor: String!
}

enum NTEPRowOrderByInput {
  id_ASC
  id_DESC
  varietyName_ASC
  varietyName_DESC
  rating_ASC
  rating_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type NTEPRowPreviousValues {
  id: ID!
  varietyName: String!
  rating: Float!
}

type NTEPRowSubscriptionPayload {
  mutation: MutationType!
  node: NTEPRow
  updatedFields: [String!]
  previousValues: NTEPRowPreviousValues
}

input NTEPRowSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: NTEPRowWhereInput
  AND: [NTEPRowSubscriptionWhereInput!]
  OR: [NTEPRowSubscriptionWhereInput!]
  NOT: [NTEPRowSubscriptionWhereInput!]
}

input NTEPRowUpdateInput {
  varietyName: String
  rating: Float
  table: NTEPTableUpdateOneWithoutRowsInput
}

input NTEPRowUpdateManyMutationInput {
  varietyName: String
  rating: Float
}

input NTEPRowUpdateManyWithoutTableInput {
  create: [NTEPRowCreateWithoutTableInput!]
  delete: [NTEPRowWhereUniqueInput!]
  connect: [NTEPRowWhereUniqueInput!]
  disconnect: [NTEPRowWhereUniqueInput!]
  update: [NTEPRowUpdateWithWhereUniqueWithoutTableInput!]
  upsert: [NTEPRowUpsertWithWhereUniqueWithoutTableInput!]
}

input NTEPRowUpdateWithoutTableDataInput {
  varietyName: String
  rating: Float
}

input NTEPRowUpdateWithWhereUniqueWithoutTableInput {
  where: NTEPRowWhereUniqueInput!
  data: NTEPRowUpdateWithoutTableDataInput!
}

input NTEPRowUpsertWithWhereUniqueWithoutTableInput {
  where: NTEPRowWhereUniqueInput!
  update: NTEPRowUpdateWithoutTableDataInput!
  create: NTEPRowCreateWithoutTableInput!
}

input NTEPRowWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  varietyName: String
  varietyName_not: String
  varietyName_in: [String!]
  varietyName_not_in: [String!]
  varietyName_lt: String
  varietyName_lte: String
  varietyName_gt: String
  varietyName_gte: String
  varietyName_contains: String
  varietyName_not_contains: String
  varietyName_starts_with: String
  varietyName_not_starts_with: String
  varietyName_ends_with: String
  varietyName_not_ends_with: String
  rating: Float
  rating_not: Float
  rating_in: [Float!]
  rating_not_in: [Float!]
  rating_lt: Float
  rating_lte: Float
  rating_gt: Float
  rating_gte: Float
  table: NTEPTableWhereInput
  AND: [NTEPRowWhereInput!]
  OR: [NTEPRowWhereInput!]
  NOT: [NTEPRowWhereInput!]
}

input NTEPRowWhereUniqueInput {
  id: ID
}

type NTEPTable {
  id: ID!
  title: String!
  subject: String!
  location: String!
  rows(where: NTEPRowWhereInput, orderBy: NTEPRowOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [NTEPRow!]
  techsheets(where: TechsheetWhereInput, orderBy: TechsheetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Techsheet!]
}

type NTEPTableConnection {
  pageInfo: PageInfo!
  edges: [NTEPTableEdge]!
  aggregate: AggregateNTEPTable!
}

input NTEPTableCreateInput {
  title: String!
  subject: String!
  location: String!
  rows: NTEPRowCreateManyWithoutTableInput
  techsheets: TechsheetCreateManyWithoutNtepTablesInput
}

input NTEPTableCreateManyWithoutTechsheetsInput {
  create: [NTEPTableCreateWithoutTechsheetsInput!]
  connect: [NTEPTableWhereUniqueInput!]
}

input NTEPTableCreateOneWithoutRowsInput {
  create: NTEPTableCreateWithoutRowsInput
  connect: NTEPTableWhereUniqueInput
}

input NTEPTableCreateWithoutRowsInput {
  title: String!
  subject: String!
  location: String!
  techsheets: TechsheetCreateManyWithoutNtepTablesInput
}

input NTEPTableCreateWithoutTechsheetsInput {
  title: String!
  subject: String!
  location: String!
  rows: NTEPRowCreateManyWithoutTableInput
}

type NTEPTableEdge {
  node: NTEPTable!
  cursor: String!
}

enum NTEPTableOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  subject_ASC
  subject_DESC
  location_ASC
  location_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type NTEPTablePreviousValues {
  id: ID!
  title: String!
  subject: String!
  location: String!
}

type NTEPTableSubscriptionPayload {
  mutation: MutationType!
  node: NTEPTable
  updatedFields: [String!]
  previousValues: NTEPTablePreviousValues
}

input NTEPTableSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: NTEPTableWhereInput
  AND: [NTEPTableSubscriptionWhereInput!]
  OR: [NTEPTableSubscriptionWhereInput!]
  NOT: [NTEPTableSubscriptionWhereInput!]
}

input NTEPTableUpdateInput {
  title: String
  subject: String
  location: String
  rows: NTEPRowUpdateManyWithoutTableInput
  techsheets: TechsheetUpdateManyWithoutNtepTablesInput
}

input NTEPTableUpdateManyMutationInput {
  title: String
  subject: String
  location: String
}

input NTEPTableUpdateManyWithoutTechsheetsInput {
  create: [NTEPTableCreateWithoutTechsheetsInput!]
  delete: [NTEPTableWhereUniqueInput!]
  connect: [NTEPTableWhereUniqueInput!]
  disconnect: [NTEPTableWhereUniqueInput!]
  update: [NTEPTableUpdateWithWhereUniqueWithoutTechsheetsInput!]
  upsert: [NTEPTableUpsertWithWhereUniqueWithoutTechsheetsInput!]
}

input NTEPTableUpdateOneWithoutRowsInput {
  create: NTEPTableCreateWithoutRowsInput
  update: NTEPTableUpdateWithoutRowsDataInput
  upsert: NTEPTableUpsertWithoutRowsInput
  delete: Boolean
  disconnect: Boolean
  connect: NTEPTableWhereUniqueInput
}

input NTEPTableUpdateWithoutRowsDataInput {
  title: String
  subject: String
  location: String
  techsheets: TechsheetUpdateManyWithoutNtepTablesInput
}

input NTEPTableUpdateWithoutTechsheetsDataInput {
  title: String
  subject: String
  location: String
  rows: NTEPRowUpdateManyWithoutTableInput
}

input NTEPTableUpdateWithWhereUniqueWithoutTechsheetsInput {
  where: NTEPTableWhereUniqueInput!
  data: NTEPTableUpdateWithoutTechsheetsDataInput!
}

input NTEPTableUpsertWithoutRowsInput {
  update: NTEPTableUpdateWithoutRowsDataInput!
  create: NTEPTableCreateWithoutRowsInput!
}

input NTEPTableUpsertWithWhereUniqueWithoutTechsheetsInput {
  where: NTEPTableWhereUniqueInput!
  update: NTEPTableUpdateWithoutTechsheetsDataInput!
  create: NTEPTableCreateWithoutTechsheetsInput!
}

input NTEPTableWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  subject: String
  subject_not: String
  subject_in: [String!]
  subject_not_in: [String!]
  subject_lt: String
  subject_lte: String
  subject_gt: String
  subject_gte: String
  subject_contains: String
  subject_not_contains: String
  subject_starts_with: String
  subject_not_starts_with: String
  subject_ends_with: String
  subject_not_ends_with: String
  location: String
  location_not: String
  location_in: [String!]
  location_not_in: [String!]
  location_lt: String
  location_lte: String
  location_gt: String
  location_gte: String
  location_contains: String
  location_not_contains: String
  location_starts_with: String
  location_not_starts_with: String
  location_ends_with: String
  location_not_ends_with: String
  rows_every: NTEPRowWhereInput
  rows_some: NTEPRowWhereInput
  rows_none: NTEPRowWhereInput
  techsheets_every: TechsheetWhereInput
  techsheets_some: TechsheetWhereInput
  techsheets_none: TechsheetWhereInput
  AND: [NTEPTableWhereInput!]
  OR: [NTEPTableWhereInput!]
  NOT: [NTEPTableWhereInput!]
}

input NTEPTableWhereUniqueInput {
  id: ID
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  nTEPRow(where: NTEPRowWhereUniqueInput!): NTEPRow
  nTEPRows(where: NTEPRowWhereInput, orderBy: NTEPRowOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [NTEPRow]!
  nTEPRowsConnection(where: NTEPRowWhereInput, orderBy: NTEPRowOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): NTEPRowConnection!
  nTEPTable(where: NTEPTableWhereUniqueInput!): NTEPTable
  nTEPTables(where: NTEPTableWhereInput, orderBy: NTEPTableOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [NTEPTable]!
  nTEPTablesConnection(where: NTEPTableWhereInput, orderBy: NTEPTableOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): NTEPTableConnection!
  techsheet(where: TechsheetWhereUniqueInput!): Techsheet
  techsheets(where: TechsheetWhereInput, orderBy: TechsheetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Techsheet]!
  techsheetsConnection(where: TechsheetWhereInput, orderBy: TechsheetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TechsheetConnection!
  toleranceRow(where: ToleranceRowWhereUniqueInput!): ToleranceRow
  toleranceRows(where: ToleranceRowWhereInput, orderBy: ToleranceRowOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ToleranceRow]!
  toleranceRowsConnection(where: ToleranceRowWhereInput, orderBy: ToleranceRowOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ToleranceRowConnection!
  toleranceTable(where: ToleranceTableWhereUniqueInput!): ToleranceTable
  toleranceTables(where: ToleranceTableWhereInput, orderBy: ToleranceTableOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ToleranceTable]!
  toleranceTablesConnection(where: ToleranceTableWhereInput, orderBy: ToleranceTableOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ToleranceTableConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

enum SeedClassification {
  VARIETY
  BLEND
  MIXTURE
}

enum Species {
  ANNUAL_RYEGRASS
  PERENNIAL_RYEGRASS
  INTERMEDIATE_RYEGRASS
  ITALIAN_RYEGRASS
  HYBRID_RYEGRASS
  BENTGRASS
  TALL_FESCUE
  FINE_FESCUE
  MEADOW_FESCUE
  BERMUDAGRASS
  BLUEGRASS
  ROUGH_BLUEGRASS
  SPECIALTY
  ALFALFA
  WHITE_CLOVER
  RED_CLOVER
  FESTULOLIUM
  TIMOTHY
  PRAIRIE_BROMEGRASS
  REED_CANARYGRASS
}

type Subscription {
  nTEPRow(where: NTEPRowSubscriptionWhereInput): NTEPRowSubscriptionPayload
  nTEPTable(where: NTEPTableSubscriptionWhereInput): NTEPTableSubscriptionPayload
  techsheet(where: TechsheetSubscriptionWhereInput): TechsheetSubscriptionPayload
  toleranceRow(where: ToleranceRowSubscriptionWhereInput): ToleranceRowSubscriptionPayload
  toleranceTable(where: ToleranceTableSubscriptionWhereInput): ToleranceTableSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type Techsheet {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  title: String!
  company: Company!
  division: Division!
  published: Boolean!
  author: User
  ntepTables(where: NTEPTableWhereInput, orderBy: NTEPTableOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [NTEPTable!]
  toleranceTable: ToleranceTable!
  isAlist: Boolean!
  classification: SeedClassification!
  species: Species!
  image: String!
  quickfacts: String!
  adaptation: String!
  seedingRate: Int!
  establishmentRate: Int!
  mowingFrequency: Int!
  nitrogenReq: Amount!
  endophyteEnhanced: Boolean!
}

type TechsheetConnection {
  pageInfo: PageInfo!
  edges: [TechsheetEdge]!
  aggregate: AggregateTechsheet!
}

input TechsheetCreateInput {
  title: String!
  company: Company!
  division: Division!
  published: Boolean
  author: UserCreateOneWithoutTechsheetsInput
  ntepTables: NTEPTableCreateManyWithoutTechsheetsInput
  toleranceTable: ToleranceTableCreateOneWithoutTechsheetInput!
  isAlist: Boolean!
  classification: SeedClassification!
  species: Species!
  image: String!
  quickfacts: String!
  adaptation: String!
  seedingRate: Int!
  establishmentRate: Int!
  mowingFrequency: Int!
  nitrogenReq: Amount!
  endophyteEnhanced: Boolean!
}

input TechsheetCreateManyWithoutAuthorInput {
  create: [TechsheetCreateWithoutAuthorInput!]
  connect: [TechsheetWhereUniqueInput!]
}

input TechsheetCreateManyWithoutNtepTablesInput {
  create: [TechsheetCreateWithoutNtepTablesInput!]
  connect: [TechsheetWhereUniqueInput!]
}

input TechsheetCreateOneWithoutToleranceTableInput {
  create: TechsheetCreateWithoutToleranceTableInput
  connect: TechsheetWhereUniqueInput
}

input TechsheetCreateWithoutAuthorInput {
  title: String!
  company: Company!
  division: Division!
  published: Boolean
  ntepTables: NTEPTableCreateManyWithoutTechsheetsInput
  toleranceTable: ToleranceTableCreateOneWithoutTechsheetInput!
  isAlist: Boolean!
  classification: SeedClassification!
  species: Species!
  image: String!
  quickfacts: String!
  adaptation: String!
  seedingRate: Int!
  establishmentRate: Int!
  mowingFrequency: Int!
  nitrogenReq: Amount!
  endophyteEnhanced: Boolean!
}

input TechsheetCreateWithoutNtepTablesInput {
  title: String!
  company: Company!
  division: Division!
  published: Boolean
  author: UserCreateOneWithoutTechsheetsInput
  toleranceTable: ToleranceTableCreateOneWithoutTechsheetInput!
  isAlist: Boolean!
  classification: SeedClassification!
  species: Species!
  image: String!
  quickfacts: String!
  adaptation: String!
  seedingRate: Int!
  establishmentRate: Int!
  mowingFrequency: Int!
  nitrogenReq: Amount!
  endophyteEnhanced: Boolean!
}

input TechsheetCreateWithoutToleranceTableInput {
  title: String!
  company: Company!
  division: Division!
  published: Boolean
  author: UserCreateOneWithoutTechsheetsInput
  ntepTables: NTEPTableCreateManyWithoutTechsheetsInput
  isAlist: Boolean!
  classification: SeedClassification!
  species: Species!
  image: String!
  quickfacts: String!
  adaptation: String!
  seedingRate: Int!
  establishmentRate: Int!
  mowingFrequency: Int!
  nitrogenReq: Amount!
  endophyteEnhanced: Boolean!
}

type TechsheetEdge {
  node: Techsheet!
  cursor: String!
}

enum TechsheetOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  title_ASC
  title_DESC
  company_ASC
  company_DESC
  division_ASC
  division_DESC
  published_ASC
  published_DESC
  isAlist_ASC
  isAlist_DESC
  classification_ASC
  classification_DESC
  species_ASC
  species_DESC
  image_ASC
  image_DESC
  quickfacts_ASC
  quickfacts_DESC
  adaptation_ASC
  adaptation_DESC
  seedingRate_ASC
  seedingRate_DESC
  establishmentRate_ASC
  establishmentRate_DESC
  mowingFrequency_ASC
  mowingFrequency_DESC
  nitrogenReq_ASC
  nitrogenReq_DESC
  endophyteEnhanced_ASC
  endophyteEnhanced_DESC
}

type TechsheetPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  title: String!
  company: Company!
  division: Division!
  published: Boolean!
  isAlist: Boolean!
  classification: SeedClassification!
  species: Species!
  image: String!
  quickfacts: String!
  adaptation: String!
  seedingRate: Int!
  establishmentRate: Int!
  mowingFrequency: Int!
  nitrogenReq: Amount!
  endophyteEnhanced: Boolean!
}

type TechsheetSubscriptionPayload {
  mutation: MutationType!
  node: Techsheet
  updatedFields: [String!]
  previousValues: TechsheetPreviousValues
}

input TechsheetSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TechsheetWhereInput
  AND: [TechsheetSubscriptionWhereInput!]
  OR: [TechsheetSubscriptionWhereInput!]
  NOT: [TechsheetSubscriptionWhereInput!]
}

input TechsheetUpdateInput {
  title: String
  company: Company
  division: Division
  published: Boolean
  author: UserUpdateOneWithoutTechsheetsInput
  ntepTables: NTEPTableUpdateManyWithoutTechsheetsInput
  toleranceTable: ToleranceTableUpdateOneRequiredWithoutTechsheetInput
  isAlist: Boolean
  classification: SeedClassification
  species: Species
  image: String
  quickfacts: String
  adaptation: String
  seedingRate: Int
  establishmentRate: Int
  mowingFrequency: Int
  nitrogenReq: Amount
  endophyteEnhanced: Boolean
}

input TechsheetUpdateManyMutationInput {
  title: String
  company: Company
  division: Division
  published: Boolean
  isAlist: Boolean
  classification: SeedClassification
  species: Species
  image: String
  quickfacts: String
  adaptation: String
  seedingRate: Int
  establishmentRate: Int
  mowingFrequency: Int
  nitrogenReq: Amount
  endophyteEnhanced: Boolean
}

input TechsheetUpdateManyWithoutAuthorInput {
  create: [TechsheetCreateWithoutAuthorInput!]
  delete: [TechsheetWhereUniqueInput!]
  connect: [TechsheetWhereUniqueInput!]
  disconnect: [TechsheetWhereUniqueInput!]
  update: [TechsheetUpdateWithWhereUniqueWithoutAuthorInput!]
  upsert: [TechsheetUpsertWithWhereUniqueWithoutAuthorInput!]
}

input TechsheetUpdateManyWithoutNtepTablesInput {
  create: [TechsheetCreateWithoutNtepTablesInput!]
  delete: [TechsheetWhereUniqueInput!]
  connect: [TechsheetWhereUniqueInput!]
  disconnect: [TechsheetWhereUniqueInput!]
  update: [TechsheetUpdateWithWhereUniqueWithoutNtepTablesInput!]
  upsert: [TechsheetUpsertWithWhereUniqueWithoutNtepTablesInput!]
}

input TechsheetUpdateOneWithoutToleranceTableInput {
  create: TechsheetCreateWithoutToleranceTableInput
  update: TechsheetUpdateWithoutToleranceTableDataInput
  upsert: TechsheetUpsertWithoutToleranceTableInput
  delete: Boolean
  disconnect: Boolean
  connect: TechsheetWhereUniqueInput
}

input TechsheetUpdateWithoutAuthorDataInput {
  title: String
  company: Company
  division: Division
  published: Boolean
  ntepTables: NTEPTableUpdateManyWithoutTechsheetsInput
  toleranceTable: ToleranceTableUpdateOneRequiredWithoutTechsheetInput
  isAlist: Boolean
  classification: SeedClassification
  species: Species
  image: String
  quickfacts: String
  adaptation: String
  seedingRate: Int
  establishmentRate: Int
  mowingFrequency: Int
  nitrogenReq: Amount
  endophyteEnhanced: Boolean
}

input TechsheetUpdateWithoutNtepTablesDataInput {
  title: String
  company: Company
  division: Division
  published: Boolean
  author: UserUpdateOneWithoutTechsheetsInput
  toleranceTable: ToleranceTableUpdateOneRequiredWithoutTechsheetInput
  isAlist: Boolean
  classification: SeedClassification
  species: Species
  image: String
  quickfacts: String
  adaptation: String
  seedingRate: Int
  establishmentRate: Int
  mowingFrequency: Int
  nitrogenReq: Amount
  endophyteEnhanced: Boolean
}

input TechsheetUpdateWithoutToleranceTableDataInput {
  title: String
  company: Company
  division: Division
  published: Boolean
  author: UserUpdateOneWithoutTechsheetsInput
  ntepTables: NTEPTableUpdateManyWithoutTechsheetsInput
  isAlist: Boolean
  classification: SeedClassification
  species: Species
  image: String
  quickfacts: String
  adaptation: String
  seedingRate: Int
  establishmentRate: Int
  mowingFrequency: Int
  nitrogenReq: Amount
  endophyteEnhanced: Boolean
}

input TechsheetUpdateWithWhereUniqueWithoutAuthorInput {
  where: TechsheetWhereUniqueInput!
  data: TechsheetUpdateWithoutAuthorDataInput!
}

input TechsheetUpdateWithWhereUniqueWithoutNtepTablesInput {
  where: TechsheetWhereUniqueInput!
  data: TechsheetUpdateWithoutNtepTablesDataInput!
}

input TechsheetUpsertWithoutToleranceTableInput {
  update: TechsheetUpdateWithoutToleranceTableDataInput!
  create: TechsheetCreateWithoutToleranceTableInput!
}

input TechsheetUpsertWithWhereUniqueWithoutAuthorInput {
  where: TechsheetWhereUniqueInput!
  update: TechsheetUpdateWithoutAuthorDataInput!
  create: TechsheetCreateWithoutAuthorInput!
}

input TechsheetUpsertWithWhereUniqueWithoutNtepTablesInput {
  where: TechsheetWhereUniqueInput!
  update: TechsheetUpdateWithoutNtepTablesDataInput!
  create: TechsheetCreateWithoutNtepTablesInput!
}

input TechsheetWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  company: Company
  company_not: Company
  company_in: [Company!]
  company_not_in: [Company!]
  division: Division
  division_not: Division
  division_in: [Division!]
  division_not_in: [Division!]
  published: Boolean
  published_not: Boolean
  author: UserWhereInput
  ntepTables_every: NTEPTableWhereInput
  ntepTables_some: NTEPTableWhereInput
  ntepTables_none: NTEPTableWhereInput
  toleranceTable: ToleranceTableWhereInput
  isAlist: Boolean
  isAlist_not: Boolean
  classification: SeedClassification
  classification_not: SeedClassification
  classification_in: [SeedClassification!]
  classification_not_in: [SeedClassification!]
  species: Species
  species_not: Species
  species_in: [Species!]
  species_not_in: [Species!]
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  quickfacts: String
  quickfacts_not: String
  quickfacts_in: [String!]
  quickfacts_not_in: [String!]
  quickfacts_lt: String
  quickfacts_lte: String
  quickfacts_gt: String
  quickfacts_gte: String
  quickfacts_contains: String
  quickfacts_not_contains: String
  quickfacts_starts_with: String
  quickfacts_not_starts_with: String
  quickfacts_ends_with: String
  quickfacts_not_ends_with: String
  adaptation: String
  adaptation_not: String
  adaptation_in: [String!]
  adaptation_not_in: [String!]
  adaptation_lt: String
  adaptation_lte: String
  adaptation_gt: String
  adaptation_gte: String
  adaptation_contains: String
  adaptation_not_contains: String
  adaptation_starts_with: String
  adaptation_not_starts_with: String
  adaptation_ends_with: String
  adaptation_not_ends_with: String
  seedingRate: Int
  seedingRate_not: Int
  seedingRate_in: [Int!]
  seedingRate_not_in: [Int!]
  seedingRate_lt: Int
  seedingRate_lte: Int
  seedingRate_gt: Int
  seedingRate_gte: Int
  establishmentRate: Int
  establishmentRate_not: Int
  establishmentRate_in: [Int!]
  establishmentRate_not_in: [Int!]
  establishmentRate_lt: Int
  establishmentRate_lte: Int
  establishmentRate_gt: Int
  establishmentRate_gte: Int
  mowingFrequency: Int
  mowingFrequency_not: Int
  mowingFrequency_in: [Int!]
  mowingFrequency_not_in: [Int!]
  mowingFrequency_lt: Int
  mowingFrequency_lte: Int
  mowingFrequency_gt: Int
  mowingFrequency_gte: Int
  nitrogenReq: Amount
  nitrogenReq_not: Amount
  nitrogenReq_in: [Amount!]
  nitrogenReq_not_in: [Amount!]
  endophyteEnhanced: Boolean
  endophyteEnhanced_not: Boolean
  AND: [TechsheetWhereInput!]
  OR: [TechsheetWhereInput!]
  NOT: [TechsheetWhereInput!]
}

input TechsheetWhereUniqueInput {
  id: ID
  title: String
}

type ToleranceRow {
  id: ID!
  toleranceName: String!
  rating: Float!
  table: ToleranceTable
}

type ToleranceRowConnection {
  pageInfo: PageInfo!
  edges: [ToleranceRowEdge]!
  aggregate: AggregateToleranceRow!
}

input ToleranceRowCreateInput {
  toleranceName: String!
  rating: Float!
  table: ToleranceTableCreateOneWithoutRowsInput
}

input ToleranceRowCreateManyWithoutTableInput {
  create: [ToleranceRowCreateWithoutTableInput!]
  connect: [ToleranceRowWhereUniqueInput!]
}

input ToleranceRowCreateWithoutTableInput {
  toleranceName: String!
  rating: Float!
}

type ToleranceRowEdge {
  node: ToleranceRow!
  cursor: String!
}

enum ToleranceRowOrderByInput {
  id_ASC
  id_DESC
  toleranceName_ASC
  toleranceName_DESC
  rating_ASC
  rating_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ToleranceRowPreviousValues {
  id: ID!
  toleranceName: String!
  rating: Float!
}

type ToleranceRowSubscriptionPayload {
  mutation: MutationType!
  node: ToleranceRow
  updatedFields: [String!]
  previousValues: ToleranceRowPreviousValues
}

input ToleranceRowSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ToleranceRowWhereInput
  AND: [ToleranceRowSubscriptionWhereInput!]
  OR: [ToleranceRowSubscriptionWhereInput!]
  NOT: [ToleranceRowSubscriptionWhereInput!]
}

input ToleranceRowUpdateInput {
  toleranceName: String
  rating: Float
  table: ToleranceTableUpdateOneWithoutRowsInput
}

input ToleranceRowUpdateManyMutationInput {
  toleranceName: String
  rating: Float
}

input ToleranceRowUpdateManyWithoutTableInput {
  create: [ToleranceRowCreateWithoutTableInput!]
  delete: [ToleranceRowWhereUniqueInput!]
  connect: [ToleranceRowWhereUniqueInput!]
  disconnect: [ToleranceRowWhereUniqueInput!]
  update: [ToleranceRowUpdateWithWhereUniqueWithoutTableInput!]
  upsert: [ToleranceRowUpsertWithWhereUniqueWithoutTableInput!]
}

input ToleranceRowUpdateWithoutTableDataInput {
  toleranceName: String
  rating: Float
}

input ToleranceRowUpdateWithWhereUniqueWithoutTableInput {
  where: ToleranceRowWhereUniqueInput!
  data: ToleranceRowUpdateWithoutTableDataInput!
}

input ToleranceRowUpsertWithWhereUniqueWithoutTableInput {
  where: ToleranceRowWhereUniqueInput!
  update: ToleranceRowUpdateWithoutTableDataInput!
  create: ToleranceRowCreateWithoutTableInput!
}

input ToleranceRowWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  toleranceName: String
  toleranceName_not: String
  toleranceName_in: [String!]
  toleranceName_not_in: [String!]
  toleranceName_lt: String
  toleranceName_lte: String
  toleranceName_gt: String
  toleranceName_gte: String
  toleranceName_contains: String
  toleranceName_not_contains: String
  toleranceName_starts_with: String
  toleranceName_not_starts_with: String
  toleranceName_ends_with: String
  toleranceName_not_ends_with: String
  rating: Float
  rating_not: Float
  rating_in: [Float!]
  rating_not_in: [Float!]
  rating_lt: Float
  rating_lte: Float
  rating_gt: Float
  rating_gte: Float
  table: ToleranceTableWhereInput
  AND: [ToleranceRowWhereInput!]
  OR: [ToleranceRowWhereInput!]
  NOT: [ToleranceRowWhereInput!]
}

input ToleranceRowWhereUniqueInput {
  id: ID
}

type ToleranceTable {
  id: ID!
  rows(where: ToleranceRowWhereInput, orderBy: ToleranceRowOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ToleranceRow!]
  techsheet: Techsheet
}

type ToleranceTableConnection {
  pageInfo: PageInfo!
  edges: [ToleranceTableEdge]!
  aggregate: AggregateToleranceTable!
}

input ToleranceTableCreateInput {
  rows: ToleranceRowCreateManyWithoutTableInput
  techsheet: TechsheetCreateOneWithoutToleranceTableInput
}

input ToleranceTableCreateOneWithoutRowsInput {
  create: ToleranceTableCreateWithoutRowsInput
  connect: ToleranceTableWhereUniqueInput
}

input ToleranceTableCreateOneWithoutTechsheetInput {
  create: ToleranceTableCreateWithoutTechsheetInput
  connect: ToleranceTableWhereUniqueInput
}

input ToleranceTableCreateWithoutRowsInput {
  techsheet: TechsheetCreateOneWithoutToleranceTableInput
}

input ToleranceTableCreateWithoutTechsheetInput {
  rows: ToleranceRowCreateManyWithoutTableInput
}

type ToleranceTableEdge {
  node: ToleranceTable!
  cursor: String!
}

enum ToleranceTableOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ToleranceTablePreviousValues {
  id: ID!
}

type ToleranceTableSubscriptionPayload {
  mutation: MutationType!
  node: ToleranceTable
  updatedFields: [String!]
  previousValues: ToleranceTablePreviousValues
}

input ToleranceTableSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ToleranceTableWhereInput
  AND: [ToleranceTableSubscriptionWhereInput!]
  OR: [ToleranceTableSubscriptionWhereInput!]
  NOT: [ToleranceTableSubscriptionWhereInput!]
}

input ToleranceTableUpdateInput {
  rows: ToleranceRowUpdateManyWithoutTableInput
  techsheet: TechsheetUpdateOneWithoutToleranceTableInput
}

input ToleranceTableUpdateOneRequiredWithoutTechsheetInput {
  create: ToleranceTableCreateWithoutTechsheetInput
  update: ToleranceTableUpdateWithoutTechsheetDataInput
  upsert: ToleranceTableUpsertWithoutTechsheetInput
  connect: ToleranceTableWhereUniqueInput
}

input ToleranceTableUpdateOneWithoutRowsInput {
  create: ToleranceTableCreateWithoutRowsInput
  update: ToleranceTableUpdateWithoutRowsDataInput
  upsert: ToleranceTableUpsertWithoutRowsInput
  delete: Boolean
  disconnect: Boolean
  connect: ToleranceTableWhereUniqueInput
}

input ToleranceTableUpdateWithoutRowsDataInput {
  techsheet: TechsheetUpdateOneWithoutToleranceTableInput
}

input ToleranceTableUpdateWithoutTechsheetDataInput {
  rows: ToleranceRowUpdateManyWithoutTableInput
}

input ToleranceTableUpsertWithoutRowsInput {
  update: ToleranceTableUpdateWithoutRowsDataInput!
  create: ToleranceTableCreateWithoutRowsInput!
}

input ToleranceTableUpsertWithoutTechsheetInput {
  update: ToleranceTableUpdateWithoutTechsheetDataInput!
  create: ToleranceTableCreateWithoutTechsheetInput!
}

input ToleranceTableWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  rows_every: ToleranceRowWhereInput
  rows_some: ToleranceRowWhereInput
  rows_none: ToleranceRowWhereInput
  techsheet: TechsheetWhereInput
  AND: [ToleranceTableWhereInput!]
  OR: [ToleranceTableWhereInput!]
  NOT: [ToleranceTableWhereInput!]
}

input ToleranceTableWhereUniqueInput {
  id: ID
}

type User {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  email: String!
  password: String!
  name: String!
  title: String!
  companies: [Company!]!
  techsheets(where: TechsheetWhereInput, orderBy: TechsheetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Techsheet!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreatecompaniesInput {
  set: [Company!]
}

input UserCreateInput {
  email: String!
  password: String!
  name: String!
  title: String
  companies: UserCreatecompaniesInput
  techsheets: TechsheetCreateManyWithoutAuthorInput
}

input UserCreateOneWithoutTechsheetsInput {
  create: UserCreateWithoutTechsheetsInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutTechsheetsInput {
  email: String!
  password: String!
  name: String!
  title: String
  companies: UserCreatecompaniesInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  name_ASC
  name_DESC
  title_ASC
  title_DESC
}

type UserPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  email: String!
  password: String!
  name: String!
  title: String!
  companies: [Company!]!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdatecompaniesInput {
  set: [Company!]
}

input UserUpdateInput {
  email: String
  password: String
  name: String
  title: String
  companies: UserUpdatecompaniesInput
  techsheets: TechsheetUpdateManyWithoutAuthorInput
}

input UserUpdateManyMutationInput {
  email: String
  password: String
  name: String
  title: String
  companies: UserUpdatecompaniesInput
}

input UserUpdateOneWithoutTechsheetsInput {
  create: UserCreateWithoutTechsheetsInput
  update: UserUpdateWithoutTechsheetsDataInput
  upsert: UserUpsertWithoutTechsheetsInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutTechsheetsDataInput {
  email: String
  password: String
  name: String
  title: String
  companies: UserUpdatecompaniesInput
}

input UserUpsertWithoutTechsheetsInput {
  update: UserUpdateWithoutTechsheetsDataInput!
  create: UserCreateWithoutTechsheetsInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  techsheets_every: TechsheetWhereInput
  techsheets_some: TechsheetWhereInput
  techsheets_none: TechsheetWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
