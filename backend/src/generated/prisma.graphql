type AggregateNTEPRow {
  count: Int!
}

type AggregateNTEPTable {
  count: Int!
}

type AggregateTechsheet {
  count: Int!
}

type AggregateTechsheetInfo {
  count: Int!
}

type AggregateToleranceRow {
  count: Int!
}

type AggregateToleranceTable {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

enum Company {
  DLF_PICKSEED
  SEED_RESEARCH_OF_OREGON
}

scalar DateTime

enum Division {
  FORAGE
  PRO_TURF
  RETAIL
}

scalar Long

type Mutation {
  createNTEPRow(data: NTEPRowCreateInput!): NTEPRow!
  updateManyNTEPRows(data: NTEPRowUpdateManyMutationInput!, where: NTEPRowWhereInput): BatchPayload!
  deleteManyNTEPRows(where: NTEPRowWhereInput): BatchPayload!
  createNTEPTable(data: NTEPTableCreateInput!): NTEPTable!
  updateManyNTEPTables(data: NTEPTableUpdateManyMutationInput!, where: NTEPTableWhereInput): BatchPayload!
  deleteManyNTEPTables(where: NTEPTableWhereInput): BatchPayload!
  createTechsheet(data: TechsheetCreateInput!): Techsheet!
  updateTechsheet(data: TechsheetUpdateInput!, where: TechsheetWhereUniqueInput!): Techsheet
  updateManyTechsheets(data: TechsheetUpdateManyMutationInput!, where: TechsheetWhereInput): BatchPayload!
  upsertTechsheet(where: TechsheetWhereUniqueInput!, create: TechsheetCreateInput!, update: TechsheetUpdateInput!): Techsheet!
  deleteTechsheet(where: TechsheetWhereUniqueInput!): Techsheet
  deleteManyTechsheets(where: TechsheetWhereInput): BatchPayload!
  createTechsheetInfo(data: TechsheetInfoCreateInput!): TechsheetInfo!
  updateManyTechsheetInfoes(data: TechsheetInfoUpdateManyMutationInput!, where: TechsheetInfoWhereInput): BatchPayload!
  deleteManyTechsheetInfoes(where: TechsheetInfoWhereInput): BatchPayload!
  createToleranceRow(data: ToleranceRowCreateInput!): ToleranceRow!
  updateManyToleranceRows(data: ToleranceRowUpdateManyMutationInput!, where: ToleranceRowWhereInput): BatchPayload!
  deleteManyToleranceRows(where: ToleranceRowWhereInput): BatchPayload!
  createToleranceTable(data: ToleranceTableCreateInput!): ToleranceTable!
  deleteManyToleranceTables(where: ToleranceTableWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type NTEPRow {
  varietyName: String!
  rating: Float!
}

type NTEPRowConnection {
  pageInfo: PageInfo!
  edges: [NTEPRowEdge]!
  aggregate: AggregateNTEPRow!
}

input NTEPRowCreateInput {
  varietyName: String!
  rating: Float!
}

input NTEPRowCreateManyInput {
  create: [NTEPRowCreateInput!]
}

type NTEPRowEdge {
  node: NTEPRow!
  cursor: String!
}

enum NTEPRowOrderByInput {
  varietyName_ASC
  varietyName_DESC
  rating_ASC
  rating_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type NTEPRowPreviousValues {
  varietyName: String!
  rating: Float!
}

type NTEPRowSubscriptionPayload {
  mutation: MutationType!
  node: NTEPRow
  updatedFields: [String!]
  previousValues: NTEPRowPreviousValues
}

input NTEPRowSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: NTEPRowWhereInput
  AND: [NTEPRowSubscriptionWhereInput!]
  OR: [NTEPRowSubscriptionWhereInput!]
  NOT: [NTEPRowSubscriptionWhereInput!]
}

input NTEPRowUpdateManyMutationInput {
  varietyName: String
  rating: Float
}

input NTEPRowWhereInput {
  varietyName: String
  varietyName_not: String
  varietyName_in: [String!]
  varietyName_not_in: [String!]
  varietyName_lt: String
  varietyName_lte: String
  varietyName_gt: String
  varietyName_gte: String
  varietyName_contains: String
  varietyName_not_contains: String
  varietyName_starts_with: String
  varietyName_not_starts_with: String
  varietyName_ends_with: String
  varietyName_not_ends_with: String
  rating: Float
  rating_not: Float
  rating_in: [Float!]
  rating_not_in: [Float!]
  rating_lt: Float
  rating_lte: Float
  rating_gt: Float
  rating_gte: Float
  AND: [NTEPRowWhereInput!]
  OR: [NTEPRowWhereInput!]
  NOT: [NTEPRowWhereInput!]
}

type NTEPTable {
  tableTitle: String!
  tableSubject: String!
  location: String!
  data(where: NTEPRowWhereInput, orderBy: NTEPRowOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [NTEPRow!]
}

type NTEPTableConnection {
  pageInfo: PageInfo!
  edges: [NTEPTableEdge]!
  aggregate: AggregateNTEPTable!
}

input NTEPTableCreateInput {
  tableTitle: String!
  tableSubject: String!
  location: String!
  data: NTEPRowCreateManyInput
}

type NTEPTableEdge {
  node: NTEPTable!
  cursor: String!
}

enum NTEPTableOrderByInput {
  tableTitle_ASC
  tableTitle_DESC
  tableSubject_ASC
  tableSubject_DESC
  location_ASC
  location_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type NTEPTablePreviousValues {
  tableTitle: String!
  tableSubject: String!
  location: String!
}

type NTEPTableSubscriptionPayload {
  mutation: MutationType!
  node: NTEPTable
  updatedFields: [String!]
  previousValues: NTEPTablePreviousValues
}

input NTEPTableSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: NTEPTableWhereInput
  AND: [NTEPTableSubscriptionWhereInput!]
  OR: [NTEPTableSubscriptionWhereInput!]
  NOT: [NTEPTableSubscriptionWhereInput!]
}

input NTEPTableUpdateManyMutationInput {
  tableTitle: String
  tableSubject: String
  location: String
}

input NTEPTableWhereInput {
  tableTitle: String
  tableTitle_not: String
  tableTitle_in: [String!]
  tableTitle_not_in: [String!]
  tableTitle_lt: String
  tableTitle_lte: String
  tableTitle_gt: String
  tableTitle_gte: String
  tableTitle_contains: String
  tableTitle_not_contains: String
  tableTitle_starts_with: String
  tableTitle_not_starts_with: String
  tableTitle_ends_with: String
  tableTitle_not_ends_with: String
  tableSubject: String
  tableSubject_not: String
  tableSubject_in: [String!]
  tableSubject_not_in: [String!]
  tableSubject_lt: String
  tableSubject_lte: String
  tableSubject_gt: String
  tableSubject_gte: String
  tableSubject_contains: String
  tableSubject_not_contains: String
  tableSubject_starts_with: String
  tableSubject_not_starts_with: String
  tableSubject_ends_with: String
  tableSubject_not_ends_with: String
  location: String
  location_not: String
  location_in: [String!]
  location_not_in: [String!]
  location_lt: String
  location_lte: String
  location_gt: String
  location_gte: String
  location_contains: String
  location_not_contains: String
  location_starts_with: String
  location_not_starts_with: String
  location_ends_with: String
  location_not_ends_with: String
  data_every: NTEPRowWhereInput
  data_some: NTEPRowWhereInput
  data_none: NTEPRowWhereInput
  AND: [NTEPTableWhereInput!]
  OR: [NTEPTableWhereInput!]
  NOT: [NTEPTableWhereInput!]
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  nTEPRows(where: NTEPRowWhereInput, orderBy: NTEPRowOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [NTEPRow]!
  nTEPRowsConnection(where: NTEPRowWhereInput, orderBy: NTEPRowOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): NTEPRowConnection!
  nTEPTables(where: NTEPTableWhereInput, orderBy: NTEPTableOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [NTEPTable]!
  nTEPTablesConnection(where: NTEPTableWhereInput, orderBy: NTEPTableOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): NTEPTableConnection!
  techsheet(where: TechsheetWhereUniqueInput!): Techsheet
  techsheets(where: TechsheetWhereInput, orderBy: TechsheetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Techsheet]!
  techsheetsConnection(where: TechsheetWhereInput, orderBy: TechsheetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TechsheetConnection!
  techsheetInfoes(where: TechsheetInfoWhereInput, orderBy: TechsheetInfoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TechsheetInfo]!
  techsheetInfoesConnection(where: TechsheetInfoWhereInput, orderBy: TechsheetInfoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TechsheetInfoConnection!
  toleranceRows(where: ToleranceRowWhereInput, orderBy: ToleranceRowOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ToleranceRow]!
  toleranceRowsConnection(where: ToleranceRowWhereInput, orderBy: ToleranceRowOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ToleranceRowConnection!
  toleranceTables(where: ToleranceTableWhereInput, orderBy: ToleranceTableOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ToleranceTable]!
  toleranceTablesConnection(where: ToleranceTableWhereInput, orderBy: ToleranceTableOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ToleranceTableConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

enum SeedClassification {
  VARIETY
  BLEND
  MIXTURE
}

enum Species {
  ANNUAL_RYEGRASS
  PERENNIAL_RYEGRASS
  INTERMEDIATE_RYEGRASS
  ITALIAN_RYEGRASS
  HYBRID_RYEGRASS
  BENTGRASS
  TALL_FESCUE
  FINE_FESCUE
  MEADOW_FESCUE
  BERMUDAGRASS
  BLUEGRASS
  ROUGH_BLUEGRASS
  SPECIALTY
  ALFALFA
  WHITE_CLOVER
  RED_CLOVER
  FESTULOLIUM
  TIMOTHY
  PRAIRIE_BROMEGRASS
  REED_CANARYGRASS
}

type Subscription {
  nTEPRow(where: NTEPRowSubscriptionWhereInput): NTEPRowSubscriptionPayload
  nTEPTable(where: NTEPTableSubscriptionWhereInput): NTEPTableSubscriptionPayload
  techsheet(where: TechsheetSubscriptionWhereInput): TechsheetSubscriptionPayload
  techsheetInfo(where: TechsheetInfoSubscriptionWhereInput): TechsheetInfoSubscriptionPayload
  toleranceRow(where: ToleranceRowSubscriptionWhereInput): ToleranceRowSubscriptionPayload
  toleranceTable(where: ToleranceTableSubscriptionWhereInput): ToleranceTableSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type Techsheet {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  title: String!
  company: Company!
  division: Division!
  published: Boolean!
  author: User
  data: TechsheetInfo!
}

type TechsheetConnection {
  pageInfo: PageInfo!
  edges: [TechsheetEdge]!
  aggregate: AggregateTechsheet!
}

input TechsheetCreateInput {
  title: String!
  company: Company!
  division: Division!
  published: Boolean
  author: UserCreateOneWithoutTechsheetsInput
  data: TechsheetInfoCreateOneInput!
}

input TechsheetCreateManyWithoutAuthorInput {
  create: [TechsheetCreateWithoutAuthorInput!]
  connect: [TechsheetWhereUniqueInput!]
}

input TechsheetCreateWithoutAuthorInput {
  title: String!
  company: Company!
  division: Division!
  published: Boolean
  data: TechsheetInfoCreateOneInput!
}

type TechsheetEdge {
  node: Techsheet!
  cursor: String!
}

type TechsheetInfo {
  isAlist: Boolean!
  classification: SeedClassification!
  species: Species!
  tolerance: ToleranceTable!
}

type TechsheetInfoConnection {
  pageInfo: PageInfo!
  edges: [TechsheetInfoEdge]!
  aggregate: AggregateTechsheetInfo!
}

input TechsheetInfoCreateInput {
  isAlist: Boolean!
  classification: SeedClassification!
  species: Species!
  tolerance: ToleranceTableCreateOneInput!
}

input TechsheetInfoCreateOneInput {
  create: TechsheetInfoCreateInput
}

type TechsheetInfoEdge {
  node: TechsheetInfo!
  cursor: String!
}

enum TechsheetInfoOrderByInput {
  isAlist_ASC
  isAlist_DESC
  classification_ASC
  classification_DESC
  species_ASC
  species_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TechsheetInfoPreviousValues {
  isAlist: Boolean!
  classification: SeedClassification!
  species: Species!
}

type TechsheetInfoSubscriptionPayload {
  mutation: MutationType!
  node: TechsheetInfo
  updatedFields: [String!]
  previousValues: TechsheetInfoPreviousValues
}

input TechsheetInfoSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TechsheetInfoWhereInput
  AND: [TechsheetInfoSubscriptionWhereInput!]
  OR: [TechsheetInfoSubscriptionWhereInput!]
  NOT: [TechsheetInfoSubscriptionWhereInput!]
}

input TechsheetInfoUpdateDataInput {
  isAlist: Boolean
  classification: SeedClassification
  species: Species
  tolerance: ToleranceTableUpdateOneRequiredInput
}

input TechsheetInfoUpdateManyMutationInput {
  isAlist: Boolean
  classification: SeedClassification
  species: Species
}

input TechsheetInfoUpdateOneRequiredInput {
  create: TechsheetInfoCreateInput
  update: TechsheetInfoUpdateDataInput
  upsert: TechsheetInfoUpsertNestedInput
}

input TechsheetInfoUpsertNestedInput {
  update: TechsheetInfoUpdateDataInput!
  create: TechsheetInfoCreateInput!
}

input TechsheetInfoWhereInput {
  isAlist: Boolean
  isAlist_not: Boolean
  classification: SeedClassification
  classification_not: SeedClassification
  classification_in: [SeedClassification!]
  classification_not_in: [SeedClassification!]
  species: Species
  species_not: Species
  species_in: [Species!]
  species_not_in: [Species!]
  tolerance: ToleranceTableWhereInput
  AND: [TechsheetInfoWhereInput!]
  OR: [TechsheetInfoWhereInput!]
  NOT: [TechsheetInfoWhereInput!]
}

enum TechsheetOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  title_ASC
  title_DESC
  company_ASC
  company_DESC
  division_ASC
  division_DESC
  published_ASC
  published_DESC
}

type TechsheetPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  title: String!
  company: Company!
  division: Division!
  published: Boolean!
}

type TechsheetSubscriptionPayload {
  mutation: MutationType!
  node: Techsheet
  updatedFields: [String!]
  previousValues: TechsheetPreviousValues
}

input TechsheetSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TechsheetWhereInput
  AND: [TechsheetSubscriptionWhereInput!]
  OR: [TechsheetSubscriptionWhereInput!]
  NOT: [TechsheetSubscriptionWhereInput!]
}

input TechsheetUpdateInput {
  title: String
  company: Company
  division: Division
  published: Boolean
  author: UserUpdateOneWithoutTechsheetsInput
  data: TechsheetInfoUpdateOneRequiredInput
}

input TechsheetUpdateManyMutationInput {
  title: String
  company: Company
  division: Division
  published: Boolean
}

input TechsheetUpdateManyWithoutAuthorInput {
  create: [TechsheetCreateWithoutAuthorInput!]
  delete: [TechsheetWhereUniqueInput!]
  connect: [TechsheetWhereUniqueInput!]
  disconnect: [TechsheetWhereUniqueInput!]
  update: [TechsheetUpdateWithWhereUniqueWithoutAuthorInput!]
  upsert: [TechsheetUpsertWithWhereUniqueWithoutAuthorInput!]
}

input TechsheetUpdateWithoutAuthorDataInput {
  title: String
  company: Company
  division: Division
  published: Boolean
  data: TechsheetInfoUpdateOneRequiredInput
}

input TechsheetUpdateWithWhereUniqueWithoutAuthorInput {
  where: TechsheetWhereUniqueInput!
  data: TechsheetUpdateWithoutAuthorDataInput!
}

input TechsheetUpsertWithWhereUniqueWithoutAuthorInput {
  where: TechsheetWhereUniqueInput!
  update: TechsheetUpdateWithoutAuthorDataInput!
  create: TechsheetCreateWithoutAuthorInput!
}

input TechsheetWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  company: Company
  company_not: Company
  company_in: [Company!]
  company_not_in: [Company!]
  division: Division
  division_not: Division
  division_in: [Division!]
  division_not_in: [Division!]
  published: Boolean
  published_not: Boolean
  author: UserWhereInput
  data: TechsheetInfoWhereInput
  AND: [TechsheetWhereInput!]
  OR: [TechsheetWhereInput!]
  NOT: [TechsheetWhereInput!]
}

input TechsheetWhereUniqueInput {
  id: ID
}

type ToleranceRow {
  toleranceName: String!
  rating: Float!
}

type ToleranceRowConnection {
  pageInfo: PageInfo!
  edges: [ToleranceRowEdge]!
  aggregate: AggregateToleranceRow!
}

input ToleranceRowCreateInput {
  toleranceName: String!
  rating: Float!
}

input ToleranceRowCreateManyInput {
  create: [ToleranceRowCreateInput!]
}

type ToleranceRowEdge {
  node: ToleranceRow!
  cursor: String!
}

enum ToleranceRowOrderByInput {
  toleranceName_ASC
  toleranceName_DESC
  rating_ASC
  rating_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ToleranceRowPreviousValues {
  toleranceName: String!
  rating: Float!
}

type ToleranceRowSubscriptionPayload {
  mutation: MutationType!
  node: ToleranceRow
  updatedFields: [String!]
  previousValues: ToleranceRowPreviousValues
}

input ToleranceRowSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ToleranceRowWhereInput
  AND: [ToleranceRowSubscriptionWhereInput!]
  OR: [ToleranceRowSubscriptionWhereInput!]
  NOT: [ToleranceRowSubscriptionWhereInput!]
}

input ToleranceRowUpdateManyInput {
  create: [ToleranceRowCreateInput!]
}

input ToleranceRowUpdateManyMutationInput {
  toleranceName: String
  rating: Float
}

input ToleranceRowWhereInput {
  toleranceName: String
  toleranceName_not: String
  toleranceName_in: [String!]
  toleranceName_not_in: [String!]
  toleranceName_lt: String
  toleranceName_lte: String
  toleranceName_gt: String
  toleranceName_gte: String
  toleranceName_contains: String
  toleranceName_not_contains: String
  toleranceName_starts_with: String
  toleranceName_not_starts_with: String
  toleranceName_ends_with: String
  toleranceName_not_ends_with: String
  rating: Float
  rating_not: Float
  rating_in: [Float!]
  rating_not_in: [Float!]
  rating_lt: Float
  rating_lte: Float
  rating_gt: Float
  rating_gte: Float
  AND: [ToleranceRowWhereInput!]
  OR: [ToleranceRowWhereInput!]
  NOT: [ToleranceRowWhereInput!]
}

type ToleranceTable {
  data(where: ToleranceRowWhereInput, orderBy: ToleranceRowOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ToleranceRow!]
}

type ToleranceTableConnection {
  pageInfo: PageInfo!
  edges: [ToleranceTableEdge]!
  aggregate: AggregateToleranceTable!
}

input ToleranceTableCreateInput {
  data: ToleranceRowCreateManyInput
}

input ToleranceTableCreateOneInput {
  create: ToleranceTableCreateInput
}

type ToleranceTableEdge {
  node: ToleranceTable!
  cursor: String!
}

enum ToleranceTableOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ToleranceTableSubscriptionPayload {
  mutation: MutationType!
  node: ToleranceTable
  updatedFields: [String!]
}

input ToleranceTableSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ToleranceTableWhereInput
  AND: [ToleranceTableSubscriptionWhereInput!]
  OR: [ToleranceTableSubscriptionWhereInput!]
  NOT: [ToleranceTableSubscriptionWhereInput!]
}

input ToleranceTableUpdateDataInput {
  data: ToleranceRowUpdateManyInput
}

input ToleranceTableUpdateOneRequiredInput {
  create: ToleranceTableCreateInput
  update: ToleranceTableUpdateDataInput
  upsert: ToleranceTableUpsertNestedInput
}

input ToleranceTableUpsertNestedInput {
  update: ToleranceTableUpdateDataInput!
  create: ToleranceTableCreateInput!
}

input ToleranceTableWhereInput {
  data_every: ToleranceRowWhereInput
  data_some: ToleranceRowWhereInput
  data_none: ToleranceRowWhereInput
  AND: [ToleranceTableWhereInput!]
  OR: [ToleranceTableWhereInput!]
  NOT: [ToleranceTableWhereInput!]
}

type User {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  email: String!
  password: String!
  name: String!
  title: String!
  companies: [Company!]!
  techsheets(where: TechsheetWhereInput, orderBy: TechsheetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Techsheet!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreatecompaniesInput {
  set: [Company!]
}

input UserCreateInput {
  email: String!
  password: String!
  name: String!
  title: String
  companies: UserCreatecompaniesInput
  techsheets: TechsheetCreateManyWithoutAuthorInput
}

input UserCreateOneWithoutTechsheetsInput {
  create: UserCreateWithoutTechsheetsInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutTechsheetsInput {
  email: String!
  password: String!
  name: String!
  title: String
  companies: UserCreatecompaniesInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  name_ASC
  name_DESC
  title_ASC
  title_DESC
}

type UserPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  email: String!
  password: String!
  name: String!
  title: String!
  companies: [Company!]!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdatecompaniesInput {
  set: [Company!]
}

input UserUpdateInput {
  email: String
  password: String
  name: String
  title: String
  companies: UserUpdatecompaniesInput
  techsheets: TechsheetUpdateManyWithoutAuthorInput
}

input UserUpdateManyMutationInput {
  email: String
  password: String
  name: String
  title: String
  companies: UserUpdatecompaniesInput
}

input UserUpdateOneWithoutTechsheetsInput {
  create: UserCreateWithoutTechsheetsInput
  update: UserUpdateWithoutTechsheetsDataInput
  upsert: UserUpsertWithoutTechsheetsInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutTechsheetsDataInput {
  email: String
  password: String
  name: String
  title: String
  companies: UserUpdatecompaniesInput
}

input UserUpsertWithoutTechsheetsInput {
  update: UserUpdateWithoutTechsheetsDataInput!
  create: UserCreateWithoutTechsheetsInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  techsheets_every: TechsheetWhereInput
  techsheets_some: TechsheetWhereInput
  techsheets_none: TechsheetWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
